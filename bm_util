#!/usr/bin/python


# -------------------------------
# ridiculously simple bookmarking
# -------------------------------

# bm         - show a list of all bookmarks
# bm a       - add current folder to list of bookmarks
# bm id	     - cd to folder with id=id
# bm d id    - delete folder with id=id from bookmark list
# bm c       - clear all dead bookmarks
# bm r       - renumber all bookmark ids
# bm f str   - find string str in all bookmark paths and cd to it
# bm s (bm_id|name|path|hits|timestamp) - sort the table by column

from pprint import pprint
import os
import sys
import re
import sqlite3
import time

# --- GLOBALS ---

SCHEMA = """
BEGIN TRANSACTION
CREATE TABLE `bookmarks` (
    `bm_id` INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE,
    `name`  TEXT,
    `path`  TEXT UNIQUE,
    `is_valid`  INTEGER DEFAULT 1 CHECK(is_valid="1" or is_valid = "0"),
    `hits`  INTEGER,
    `timestamp` TEXT
);
COMMIT;
END TRANSACTION
"""

RENUMBER = """
BEGIN TRANSACTION;
CREATE TABLE `bookmarks_backup` (
    `bm_id` INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE,
    `name`  TEXT,
    `path`  TEXT UNIQUE,
    `is_valid`  INTEGER DEFAULT 1 CHECK(is_valid="1" or is_valid = "0"),
    `hits`  INTEGER,
    `timestamp` TEXT
);
INSERT INTO bookmarks_backup (name, path, is_valid, hits, timestamp) SELECT name, path, is_valid, hits, timestamp FROM bookmarks;
DROP TABLE bookmarks;
ALTER TABLE bookmarks_backup RENAME TO bookmarks;
COMMIT;
"""

DB_PATH = "~/.bookmarks.db"
TABLE_NAME = "bookmarks"

# --- GLOBALS END ---

def shellquote(s):
    s = s.replace("'", "\'")
    return s

# pretty print the cursor (with appropriate table size)
def pp(cursor, data=None, rowlens=0):
    d = cursor.description
    if not d:
        return "You have no bookmark. Type 'bm a' to add a new bookmark!"

    if not data:
        data = cursor.fetchall()

    no_of_cols = len(d)
    no_of_rows = len(data)

    # printing will require two passes
    # PASS1: Determine max lengths in each column
    # PASS2: Print the column using the data from PASS1

    # PASS1
    max_col_lengths = []
    for col in range(no_of_cols):
        max_col_lengths.append(len(d[col][0]))

    for col in range(no_of_cols):
        this_col_max =  max_col_lengths[col]
        for row in range(no_of_rows):
            l = len(str(data[row][col]))
            this_col_max = max(this_col_max, l)
        max_col_lengths[col] = this_col_max


    # PASS2
    total_width = sum(max_col_lengths) + 2*no_of_cols + no_of_cols + 1
    separator = '-' * total_width 

    print separator

    # print headers
    header = []
    for col in range(no_of_cols):
        header.append("|")
        no_of_spaces = max_col_lengths[col] - len(d[col][0])
        header.append(d[col][0] + no_of_spaces*' ')
    header.append("|")

    print " ".join(header)
    print separator
    
    for row in range(no_of_rows):
        the_row = []
        for col in range(no_of_cols):
            the_row.append("|")
            no_of_spaces = max_col_lengths[col] - len(str(data[row][col]))
            the_row.append(str(data[row][col]) + no_of_spaces*' ')
        the_row.append("|")
        print " ".join(the_row)

    print separator



class DatabaseManager(object):
    def __init__(self):
        self.conn = sqlite3.connect(os.path.expanduser(DB_PATH))
        try:
            self.conn.executescript(SCHEMA)
        except:
            pass
        self.cur = self.conn.cursor()

    def query(self, arg, tup=()):
        try:
            self.cur.execute(arg, tup)
        except sqlite3.IntegrityError:
            print "Folder already bookmarked!"
        self.conn.commit()
        return self.cur

    def __del__(self):
        self.conn.close()


def get_dir_name(path):
    r = re.search('.*/([^/]*)', path)
    return r.group(1)


def main():
    db = DatabaseManager()

    # 'bm'
    if len(sys.argv) < 2:
        bm(db)
    # 'bm a'
    elif sys.argv[1] == 'a':
        bm_a(db)


    # 'bm d id'
    elif sys.argv[1] == 'd':
        try:
            id = int(sys.argv[2])
        except:
            print "To delete bookmark 5, type:\n\n\tbm d 5\n"
            exit()

        bm_d_id(db, id)

    # 'bm r'
    elif sys.argv[1] == 'r':
        db.conn.executescript(RENUMBER)

    # 'bm f str'
    elif sys.argv[1] == 'f':
        str = sys.argv[2]
        bm_f_str(db, str)

    # 'bm s value'
    elif sys.argv[1] == 's':
        col = sys.argv[2]
        bm_s(db, col)
        

    else:
        # goto bookmark, if number is valid
        try:
            id = int(sys.argv[1])
        except ValueError:
            print "To goto bookmark 5, type:\n\n\tbm 5\n"
            exit()

        bm_id(db, id)



def update_validity(db, invalid_ids, valid_ids):
    statement = "UPDATE " + TABLE_NAME + " SET is_valid='0' WHERE bm_id=?"
    for id in invalid_ids:
        db.query(statement, (id, ))

    statement = "UPDATE " + TABLE_NAME + " SET is_valid='1' WHERE bm_id=?"
    for id in valid_ids:
        db.query(statement, (id, ))


class cc:
    def __init__(self, cur):
        self.description = cur.description


# Interface functions
def bm(db):
    statement = "SELECT bm_id, name, path  FROM " + TABLE_NAME
    cur = db.query(statement)
    cur_copy = cc(cur)
    results = cur.fetchall()

    # declare valid_ids & invalid_ids array
    invalid_ids = []
    valid_ids = []

    # go over each result
    for result in results:
        id = result[0] 
        path = result[2]

        # if current path invalid, append it to invalid_ids
        if not os.path.isdir(path):
            invalid_ids.append(id)
            # mark for coloring red
        else:
            valid_ids.append(id)

    # call update_validity(db, invalid_ids)
    update_validity(db, invalid_ids, valid_ids)

    pp(cur_copy, results)


def bm_a(db):
    bm_id = None
    bm_path = os.getcwd()
    bm_name = get_dir_name(bm_path)
    bm_isvalid = "1"
    bm_hits = "0"
    bm_timestamp = time.time()

    statement = "INSERT INTO " + TABLE_NAME + " VALUES (?, ?, ?, ?, ?, ?)"
    tup = (bm_id, bm_name, bm_path, bm_isvalid, bm_hits, bm_timestamp)
    db.query(statement, tup)


def bm_id(db, id):
    statement = "SELECT * FROM " + TABLE_NAME + " WHERE bm_id=?"
    cur = db.query(statement, (id, ))
    res =  cur.fetchone()
    new_hits = res[4] + 1
    statement = "UPDATE " + TABLE_NAME + " SET hits=? WHERE bm_id=?"
    db.query(statement, (new_hits,id))
    print shellquote(res[2])


def bm_d_id(db, id):
    statement = "DELETE FROM " + TABLE_NAME + " WHERE bm_id=?"
    db.query(statement, (id, ))


def bm_c():
    pass


def bm_f_str(db, str):
    statement = "SELECT bm_id, name, path FROM " + TABLE_NAME + " WHERE path like '%"+str+"%'"
    cur = db.query(statement)
    pp(cur)


def bm_s(db, col):
    opts = ["bm_id", "name", "path",  "hits", "timestamp"]
    if col in opts:
        statement = "SELECT bm_id, name, path FROM " + TABLE_NAME + " ORDER BY " + col
        cur = db.query(statement)
        pp(cur)
    else:
        print "Sort parameter should be one of the following: "
        for opt in opts:
            print opt
     

# Internal functions
def print_complete_table(sort="id"):
    pass


def change_directory(path="/home"):
    pass


def is_path_valid(path="/home"):
    pass



# Cursor row parsers (return strings)
def get_str_id(cursor="c"):
    pass

def get_str_name(cursor="c"):
    pass

def get_str_path(cursor="c"):
    pass

def get_str_hits(cursor="c"):
    pass

def get_str_time(cursor="c"):
    pass


# sqlite functions (returns cursors)
def get_cur_all_rows():
    pass


def get_cur_row(id=1):
    pass


def get_cur_row_find(str="str"):
    pass



# sqlite functions (return 1 = success or 0 = failure)
def del_row(id=1):
    pass

if __name__ == "__main__":
    main()
