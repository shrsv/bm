#!/usr/bin/python


# -------------------------------
# ridiculously simple bookmarking
# -------------------------------

# bm         - show a list of all bookmarks
# bm a       - add current folder to list of bookmarks
# bm id	     - cd to folder with id=id
# bm d id    - delete folder with id=id from bookmark list
# bm c       - clear all dead bookmarks
# bm r       - renumber all bookmark ids
# bm f str   - find string str in all bookmark paths and cd to it
# bm s (bm_id|name|path|hits|timestamp) - sort the table by column

import os
import sys
import re
import sqlite3
import time

# --- GLOBALS ---

SCHEMA = """
BEGIN TRANSACTION
CREATE TABLE `bookmarks` (
    `bm_id` INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE,
    `name`  TEXT,
    `path`  TEXT UNIQUE,
    `is_valid`  INTEGER DEFAULT 1 CHECK(is_valid="1" or is_valid = "0"),
    `hits`  INTEGER,
    `timestamp` TEXT
);
COMMIT;
END TRANSACTION
"""

RENUMBER = """
BEGIN TRANSACTION;
CREATE TABLE `bookmarks_backup` (
    `bm_id` INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE,
    `name`  TEXT,
    `path`  TEXT UNIQUE,
    `is_valid`  INTEGER DEFAULT 1 CHECK(is_valid="1" or is_valid = "0"),
    `hits`  INTEGER,
    `timestamp` TEXT
);
INSERT INTO bookmarks_backup (name, path, is_valid, hits, timestamp) SELECT name, path, is_valid, hits, timestamp FROM bookmarks;
DROP TABLE bookmarks;
ALTER TABLE bookmarks_backup RENAME TO bookmarks;
COMMIT;
"""

DB_PATH = "~/.bookmarks.db"
TABLE_NAME = "bookmarks"

# --- GLOBALS END ---

def shellquote(s):
    s = s.replace("'", "\'")
    return s

# from: http://code.activestate.com/recipes/81189-pretty-printing-of-database-cursor-contents/
# One of the problems of dealing with databases is presenting the result of a query when you may not know much about the data. 
# This recipe uses the cursor's description attribute to try and provide appropriate headings,
# and optionally examines each output row to ensure column widths are adequate.

def pp(cursor, data=None, rowlens=0):
    d = cursor.description
    if not d:
        return "#### NO RESULTS ###"
    names = []
    lengths = []
    rules = []
    if not data:
        data = cursor.fetchall()
    for dd in d:    # iterate over description
        l = dd[1]
        if not l:
            l = 12             # or default arg ...
        l = max(l, len(dd[0])) # handle long names
        names.append(dd[0])
        lengths.append(l)
    for col in range(len(lengths)):
        if rowlens:
            rls = [len(str(row[col])) for row in data if row[col]]
            lengths[col] = max([lengths[col]]+rls)
        rules.append("-"*lengths[col])
    format = " ".join(["%%-%ss" % l for l in lengths])
    result = [format % tuple(names)]
    result.append(format % tuple(rules))
    for row in data:
        result.append(format % row)
    return "\n".join(result)



class DatabaseManager(object):
    def __init__(self):
        self.conn = sqlite3.connect(os.path.expanduser(DB_PATH))
        try:
            self.conn.executescript(SCHEMA)
        except:
            pass
        self.cur = self.conn.cursor()

    def query(self, arg, tup=()):
        try:
            self.cur.execute(arg, tup)
        except sqlite3.IntegrityError:
            print "Folder already bookmarked!"
        self.conn.commit()
        return self.cur

    def __del__(self):
        self.conn.close()


def get_dir_name(path):
    r = re.search('.*/([^/]*)', path)
    return r.group(1)


def main():
    db = DatabaseManager()

    # 'bm'
    if len(sys.argv) < 2:
        bm(db)
    # 'bm a'
    elif sys.argv[1] == 'a':
        bm_a(db)


    # 'bm d id'
    elif sys.argv[1] == 'd':
        try:
            id = int(sys.argv[2])
        except:
            print "To delete bookmark 5, type:\n\n\tbm d 5\n"
            exit()

        bm_d_id(db, id)

    # 'bm r'
    elif sys.argv[1] == 'r':
        db.conn.executescript(RENUMBER)

    # 'bm f str'
    elif sys.argv[1] == 'f':
        str = sys.argv[2]
        bm_f_str(db, str)

    # 'bm s value'
    elif sys.argv[1] == 's':
        col = sys.argv[2]
        bm_s(db, col)
        

    else:
        # goto bookmark, if number is valid
        try:
            id = int(sys.argv[1])
        except ValueError:
            print "To goto bookmark 5, type:\n\n\tbm 5\n"
            exit()

        bm_id(db, id)



# Interface functions
def bm(db):
    statement = "SELECT bm_id, name, path  FROM " + TABLE_NAME
    cur = db.query(statement)
    print pp(cur)


def bm_a(db):
    bm_id = None
    bm_path = os.getcwd()
    bm_name = get_dir_name(bm_path)
    bm_isvalid = "1"
    bm_hits = "0"
    bm_timestamp = time.time()

    statement = "INSERT INTO " + TABLE_NAME + " VALUES (?, ?, ?, ?, ?, ?)"
    tup = (bm_id, bm_name, bm_path, bm_isvalid, bm_hits, bm_timestamp)
    db.query(statement, tup)


def bm_id(db, id):
    statement = "SELECT * FROM " + TABLE_NAME + " WHERE bm_id=?"
    cur = db.query(statement, (id, ))
    res =  cur.fetchone()
    new_hits = res[4] + 1
    statement = "UPDATE " + TABLE_NAME + " SET hits=? WHERE bm_id=?"
    db.query(statement, (new_hits,id))
    print shellquote(res[2])


def bm_d_id(db, id):
    statement = "DELETE FROM " + TABLE_NAME + " WHERE bm_id=?"
    db.query(statement, (id, ))


def bm_c():
    pass


def bm_f_str(db, str):
    statement = "SELECT bm_id, name, path FROM " + TABLE_NAME + " WHERE path like '%"+str+"%'"
    cur = db.query(statement)
    print pp(cur)


def bm_s(db, col):
    opts = ["bm_id", "name", "path",  "hits", "timestamp"]
    if col in opts:
        statement = "SELECT bm_id, name, path FROM " + TABLE_NAME + " ORDER BY " + col
        cur = db.query(statement)
        print pp(cur)
    else:
        print "Sort parameter should be one of the following: "
        for opt in opts:
            print opt
     

# Internal functions
def print_complete_table(sort="id"):
    pass


def change_directory(path="/home"):
    pass


def is_path_valid(path="/home"):
    pass



# Cursor row parsers (return strings)
def get_str_id(cursor="c"):
    pass

def get_str_name(cursor="c"):
    pass

def get_str_path(cursor="c"):
    pass

def get_str_hits(cursor="c"):
    pass

def get_str_time(cursor="c"):
    pass


# sqlite functions (returns cursors)
def get_cur_all_rows():
    pass


def get_cur_row(id=1):
    pass


def get_cur_row_find(str="str"):
    pass



# sqlite functions (return 1 = success or 0 = failure)
def del_row(id=1):
    pass

if __name__ == "__main__":
    main()
